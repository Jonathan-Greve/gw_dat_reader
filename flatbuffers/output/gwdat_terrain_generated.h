// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GWDATTERRAIN_GWDAT_H_
#define FLATBUFFERS_GENERATED_GWDATTERRAIN_GWDAT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "gwdat_filename_generated.h"

namespace GWDat {

struct GWDatTerrain;
struct GWDatTerrainBuilder;

struct TerrainReply;
struct TerrainReplyBuilder;

struct TerrainRequest;
struct TerrainRequestBuilder;

struct GWDatTerrain FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GWDatTerrainBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_ID = 4,
    VT_GWDAT_FILENAME = 6,
    VT_FILE_SIZE = 8
  };
  uint32_t file_id() const {
    return GetField<uint32_t>(VT_FILE_ID, 0);
  }
  const GWDat::GWDatfilename *gwdat_filename() const {
    return GetStruct<const GWDat::GWDatfilename *>(VT_GWDAT_FILENAME);
  }
  uint32_t file_size() const {
    return GetField<uint32_t>(VT_FILE_SIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FILE_ID, 4) &&
           VerifyField<GWDat::GWDatfilename>(verifier, VT_GWDAT_FILENAME, 2) &&
           VerifyField<uint32_t>(verifier, VT_FILE_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct GWDatTerrainBuilder {
  typedef GWDatTerrain Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_file_id(uint32_t file_id) {
    fbb_.AddElement<uint32_t>(GWDatTerrain::VT_FILE_ID, file_id, 0);
  }
  void add_gwdat_filename(const GWDat::GWDatfilename *gwdat_filename) {
    fbb_.AddStruct(GWDatTerrain::VT_GWDAT_FILENAME, gwdat_filename);
  }
  void add_file_size(uint32_t file_size) {
    fbb_.AddElement<uint32_t>(GWDatTerrain::VT_FILE_SIZE, file_size, 0);
  }
  explicit GWDatTerrainBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GWDatTerrain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GWDatTerrain>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GWDatTerrain> CreateGWDatTerrain(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t file_id = 0,
    const GWDat::GWDatfilename *gwdat_filename = nullptr,
    uint32_t file_size = 0) {
  GWDatTerrainBuilder builder_(_fbb);
  builder_.add_file_size(file_size);
  builder_.add_gwdat_filename(gwdat_filename);
  builder_.add_file_id(file_id);
  return builder_.Finish();
}

struct TerrainReply FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TerrainReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GW_DAT_TERRAIN = 4
  };
  const GWDat::GWDatTerrain *gw_dat_terrain() const {
    return GetPointer<const GWDat::GWDatTerrain *>(VT_GW_DAT_TERRAIN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GW_DAT_TERRAIN) &&
           verifier.VerifyTable(gw_dat_terrain()) &&
           verifier.EndTable();
  }
};

struct TerrainReplyBuilder {
  typedef TerrainReply Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_gw_dat_terrain(::flatbuffers::Offset<GWDat::GWDatTerrain> gw_dat_terrain) {
    fbb_.AddOffset(TerrainReply::VT_GW_DAT_TERRAIN, gw_dat_terrain);
  }
  explicit TerrainReplyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TerrainReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TerrainReply>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TerrainReply> CreateTerrainReply(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<GWDat::GWDatTerrain> gw_dat_terrain = 0) {
  TerrainReplyBuilder builder_(_fbb);
  builder_.add_gw_dat_terrain(gw_dat_terrain);
  return builder_.Finish();
}

struct TerrainRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TerrainRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_ID = 4
  };
  uint32_t file_id() const {
    return GetField<uint32_t>(VT_FILE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FILE_ID, 4) &&
           verifier.EndTable();
  }
};

struct TerrainRequestBuilder {
  typedef TerrainRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_file_id(uint32_t file_id) {
    fbb_.AddElement<uint32_t>(TerrainRequest::VT_FILE_ID, file_id, 0);
  }
  explicit TerrainRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TerrainRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TerrainRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TerrainRequest> CreateTerrainRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t file_id = 0) {
  TerrainRequestBuilder builder_(_fbb);
  builder_.add_file_id(file_id);
  return builder_.Finish();
}

}  // namespace GWDat

#endif  // FLATBUFFERS_GENERATED_GWDATTERRAIN_GWDAT_H_
